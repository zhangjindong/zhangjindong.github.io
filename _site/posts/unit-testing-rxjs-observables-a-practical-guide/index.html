<!DOCTYPE html>
<html lang="en">
<head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link href="https://fonts.googleapis.com/css?family=Nunito+Sans:400,400i,700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="/assets/css/style.css">
<title>RxJS Observables 单元测试 – 实用指南</title>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>RxJS Observables 单元测试 – 实用指南 | 青木瓜</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="RxJS Observables 单元测试 – 实用指南" />
<meta name="author" content="张锦栋" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="由于 RxJS 观察链的异步特性，对其进行单元测试可能具有挑战性。我们最新的技术博客着眼于简化这个过程。" />
<meta property="og:description" content="由于 RxJS 观察链的异步特性，对其进行单元测试可能具有挑战性。我们最新的技术博客着眼于简化这个过程。" />
<link rel="canonical" href="http://localhost:4000/posts/unit-testing-rxjs-observables-a-practical-guide/" />
<meta property="og:url" content="http://localhost:4000/posts/unit-testing-rxjs-observables-a-practical-guide/" />
<meta property="og:site_name" content="青木瓜" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-04-15T09:48:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="RxJS Observables 单元测试 – 实用指南" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"张锦栋"},"dateModified":"2024-04-15T09:48:00+08:00","datePublished":"2024-04-15T09:48:00+08:00","description":"由于 RxJS 观察链的异步特性，对其进行单元测试可能具有挑战性。我们最新的技术博客着眼于简化这个过程。","headline":"RxJS Observables 单元测试 – 实用指南","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/posts/unit-testing-rxjs-observables-a-practical-guide/"},"url":"http://localhost:4000/posts/unit-testing-rxjs-observables-a-practical-guide/"}</script>
<!-- End Jekyll SEO tag -->
</head>
<body>
  <header class="texture-blue">
    <div class="container"><div class="navbar">
	<ul>
		
	</ul>
</div></div><div class="container">
	<h1>RxJS Observables 单元测试 – 实用指南</h1>
	<h4 class="post-description">由于 RxJS 观察链的异步特性，对其进行单元测试可能具有挑战性。我们最新的技术博客着眼于简化这个过程。</h4>
	<div class="post-date" style="margin-top:20px">
		Published on Apr 15, 2024
	</div>
	<ul class="post-tags"><li>Rxjs</li><li>Vitest</li></ul>
</div>
</header>
  <main>
    <div class="container">
      <div class="post-container">
          <p>由于 RxJS 观察链的异步特性，对其进行单元测试可能具有挑战性。</p>

<p>目录表</p>

<ul>
  <li>RxJS 可观察对象单元测试中的挑战</li>
  <li>技术的先决条件</li>
  <li>单元测试目标</li>
  <li>RxJS 观察链单元测试:解决方案概述</li>
  <li>单元测试 RxJS 观察链:解决方案示例</li>
  <li>RxJS 观察链单元测试:解决方案概述</li>
  <li>进一步的资源</li>
  <li>附录 A:考虑单元测试 RxJS 观察链的替代解决方案</li>
</ul>

<h2 id="rxjs-可观察对象单元测试中的挑战">RxJS 可观察对象单元测试中的挑战</h2>

<p>Adaptive 为其资本市场客户构建的用户界面(ui)通常是“反应性的”，这意味着它们的视图会随着金融市场的变化而实时更新。在 Adaptive，我们倾向于使用 RxJS 的可观察对象来管理应用程序状态，将它们绑定到 UI 组件上，这样当可观察对象发出时，视图就会更新。在应用程序的状态层中，我们经常通过将操作符函数传递给 pipe()方法来定义重要的观察链。这些观察链定义了如何组合来自多个数据源的数据，并将其转换为 UI 组件要使用的视图模型对象。</p>

<p>这些观察链中逻辑的正确性通常对应用程序的行为至关重要，<strong>但单元测试可能具有挑战性，因为随着时间的推移，可观察对象会异步发出多个值。</strong></p>

<p>那么，我们如何才能有效地对 RxJS 观察链进行单元测试，以验证它们的行为是否符合我们的预期呢?</p>

<h2 id="技术的先决条件">技术的先决条件</h2>

<p>假定读者熟悉 TypeScript、RxJS 和单元测试框架(如 Vitest 或 Jest)。本文将不关注任何特定的 UI 框架或视图/组件库。如果你正在使用 RxJS 以响应式的方式管理应用状态，那么无论你使用的是 React、Vue.js、Angular 还是其他框架，这些内容都应该是相关的。</p>

<p>本文中的示例代码可以在随附的 GitHub repo 中找到。在本文中，您可以使用 repo 中的标记跟踪示例的开发进度。</p>

<h2 id="单元测试目标">单元测试目标</h2>

<p>Adaptive 团队希望能够测试由观察链创建的可观察对象发出的各种状态排列，并通过它所依赖的上游源可观察对象向所述链提供各种输入。</p>

<p>我们想要测试的单元是按原样导出的有状态可观察对象，或者是接受键(比如实体 ID)并返回可观察对象的函数。例如，下面的观察链，本文将演示如何进行单元测试。</p>

<p>Stage 1: state.ts</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">Observable</span><span class="p">,</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">mergeWith</span><span class="p">,</span> <span class="nx">scan</span><span class="p">,</span> <span class="nx">startWith</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">rxjs</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">pricesDto$</span><span class="p">,</span> <span class="nx">resetPrices$</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./service</span><span class="dl">"</span><span class="p">;</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">prices$</span><span class="p">:</span> <span class="nx">Observable</span><span class="o">&lt;</span><span class="nx">Record</span><span class="o">&lt;</span><span class="nx">string</span><span class="p">,</span> <span class="nx">number</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nx">pricesDto$</span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span>
  <span class="nx">scan</span><span class="p">(</span>
    <span class="p">(</span><span class="nx">accum</span><span class="p">,</span> <span class="nx">current</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
      <span class="p">...</span><span class="nx">accum</span><span class="p">,</span>
      <span class="p">[</span><span class="nx">current</span><span class="p">.</span><span class="nx">symbol</span><span class="p">]:</span> <span class="nx">current</span><span class="p">.</span><span class="nx">price</span><span class="p">,</span>
    <span class="p">}),</span>
    <span class="p">{}</span>
  <span class="p">),</span>
  <span class="nx">mergeWith</span><span class="p">(</span><span class="nx">resetPrices$</span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">map</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">({})))),</span>
  <span class="nx">startWith</span><span class="p">({})</span>
<span class="p">);</span>
</code></pre></div></div>

<p>在开发我们在这里展示的模式之前，我们探索并拒绝了附录 A:为 RxJS 观察链单元测试考虑的替代解决方案中描述的一些方法。</p>

<h2 id="rxjs-观察链单元测试解决方案概述">RxJS 观察链单元测试:解决方案概述</h2>

<p>正如我们将在下面演示的那样，我们通过使用 spy 函数订阅被测对象来实现我们的测试目标，这样我们就可以断言所发出的内容，并用 RxJS 主题模拟源可观察对象。我们通过一个非常小的实用函数 spyOnObservable()来实现这一点，它抽象了与监视观察者相关的样板文件。我们在这里使用的是 Vitest，但如果您使用的是 Jest，则语义非常相似。如果您使用不同的测试库(如 Mocha、Jasmine 或 Qunit)，语义可能会有点不同，但概念和功能应该很容易转移。</p>

<p>spyOnObservable.ts</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">Observable</span><span class="p">,</span> <span class="nx">Subscription</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">rxjs</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">Mock</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">vitest</span><span class="dl">'</span>
<span class="o">/</span><span class="err">\</span><span class="o">*</span><span class="err">\</span><span class="o">*</span>

<span class="o">-</span> <span class="nx">Utility</span> <span class="kd">function</span> <span class="k">for</span> <span class="nx">testing</span> <span class="nx">observables</span><span class="p">.</span>
<span class="o">-</span> <span class="nx">Returns</span> <span class="nx">an</span> <span class="nx">object</span> <span class="nx">containing</span> <span class="nx">mock</span> <span class="nx">observer</span> <span class="nx">functions</span><span class="p">.</span>
<span class="o">-</span>
<span class="o">-</span> <span class="nx">To</span> <span class="nx">ensure</span> <span class="nx">your</span> <span class="nx">test</span> <span class="nx">does</span> <span class="nx">not</span> <span class="nx">cause</span> <span class="nx">a</span> <span class="nx">memory</span> <span class="nx">leak</span><span class="p">,</span> <span class="nx">assert</span> <span class="nx">that</span> <span class="s2">`complete`</span>
<span class="o">-</span> <span class="nx">has</span> <span class="nx">been</span> <span class="nx">called</span><span class="p">;</span> <span class="k">this</span> <span class="nx">will</span> <span class="nx">verify</span> <span class="nx">that</span> <span class="k">this</span> <span class="nx">utility</span> <span class="nx">has</span> <span class="nx">unsubscribed</span>
<span class="o">-</span> <span class="k">from</span> <span class="nx">the</span> <span class="nx">observable</span> <span class="nx">under</span> <span class="nx">test</span><span class="p">.</span> <span class="nx">Alternatively</span><span class="p">,</span> <span class="nx">explicitly</span> <span class="nx">unsubscribe</span>
<span class="o">-</span> <span class="nx">the</span> <span class="nx">subscription</span> <span class="nx">that</span> <span class="nx">is</span> <span class="nx">returned</span><span class="p">.</span>
<span class="o">-</span>
<span class="o">-</span> <span class="nx">Example</span> <span class="nx">usage</span><span class="p">:</span>
<span class="o">-</span>
<span class="o">-</span> <span class="kd">const</span> <span class="p">{</span> <span class="nx">next</span><span class="p">,</span> <span class="nx">error</span><span class="p">,</span> <span class="nx">complete</span><span class="p">,</span> <span class="nx">subscription</span><span class="p">,</span> <span class="nx">latestEmission</span><span class="p">,</span> <span class="nx">emissionCount</span> <span class="p">}</span> <span class="o">=</span>
<span class="o">-</span>      <span class="nx">spyOnObservable</span><span class="p">(</span><span class="nx">observableToTest$</span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">take</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
<span class="o">-</span>
<span class="o">-</span> <span class="nx">expect</span><span class="p">(</span><span class="nx">next</span><span class="p">).</span><span class="nx">toHaveBeenCalledTimes</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="o">-</span> <span class="nx">expect</span><span class="p">(</span><span class="nx">next</span><span class="p">).</span><span class="nx">toHaveBeenCalledWith</span><span class="p">(</span><span class="nx">someValue</span><span class="p">)</span>
<span class="o">-</span> <span class="nx">expect</span><span class="p">(</span><span class="nx">latestEmission</span><span class="p">()).</span><span class="nx">toBe</span><span class="p">(</span><span class="nx">someValue</span><span class="p">)</span>
<span class="o">-</span> <span class="nx">expect</span><span class="p">(</span><span class="nx">error</span><span class="p">).</span><span class="nx">not</span><span class="p">.</span><span class="nx">toHaveBeenCalled</span><span class="p">()</span>
<span class="o">-</span> <span class="nx">subscription</span><span class="p">.</span><span class="nx">unsubscribe</span><span class="p">()</span>
<span class="o">-</span> <span class="nx">expect</span><span class="p">(</span><span class="nx">complete</span><span class="p">).</span><span class="nx">toHaveBeenCalled</span><span class="p">()</span>
  <span class="err">\</span><span class="o">*</span><span class="sr">/</span><span class="err">
</span>  <span class="k">export</span> <span class="kd">function</span> <span class="nx">spyOnObservable</span><span class="p">(</span><span class="nx">observable$</span><span class="p">:</span> <span class="nx">Observable</span><span class="o">&lt;</span><span class="nx">unknown</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">next</span><span class="p">:</span> <span class="nx">Mock</span><span class="o">&lt;</span><span class="nx">any</span><span class="p">,</span> <span class="nx">any</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">vi</span><span class="p">.</span><span class="nx">fn</span><span class="p">()</span>
  <span class="kd">const</span> <span class="nx">error</span><span class="p">:</span> <span class="nx">Mock</span><span class="o">&lt;</span><span class="nx">any</span><span class="p">,</span> <span class="nx">any</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">vi</span><span class="p">.</span><span class="nx">fn</span><span class="p">()</span>
  <span class="kd">const</span> <span class="nx">complete</span><span class="p">:</span> <span class="nx">Mock</span><span class="o">&lt;</span><span class="nx">any</span><span class="p">,</span> <span class="nx">any</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">vi</span><span class="p">.</span><span class="nx">fn</span><span class="p">()</span>
  <span class="kd">const</span> <span class="nx">emissionCount</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">next</span><span class="p">.</span><span class="nx">mock</span><span class="p">.</span><span class="nx">calls</span><span class="p">.</span><span class="nx">length</span>
  <span class="kd">const</span> <span class="nx">latestEmission</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">next</span><span class="p">.</span><span class="nx">mock</span><span class="p">.</span><span class="nx">calls</span><span class="p">.</span><span class="nx">at</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">!</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">expected next to have been called</span><span class="dl">'</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">subscription</span><span class="p">:</span> <span class="nx">Subscription</span>
  <span class="nx">subscription</span> <span class="o">=</span> <span class="nx">observable$</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">({</span>
  <span class="nx">next</span><span class="p">,</span>
  <span class="nx">error</span><span class="p">,</span>
  <span class="na">complete</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">subscription</span><span class="p">?.</span><span class="nx">unsubscribe</span><span class="p">()</span>
  <span class="nx">complete</span><span class="p">()</span>
  <span class="p">},</span>
  <span class="p">})</span>
  <span class="k">return</span> <span class="p">{</span> <span class="nx">next</span><span class="p">,</span> <span class="nx">error</span><span class="p">,</span> <span class="nx">complete</span><span class="p">,</span> <span class="nx">subscription</span><span class="p">,</span> <span class="nx">latestEmission</span><span class="p">,</span> <span class="nx">emissionCount</span> <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></div>

<h2 id="单元测试-rxjs-观察链解决方案示例">单元测试 RxJS 观察链:解决方案示例</h2>

<p>我们将使用以下虚构的用例来演示如何在现实生活中应用它。我们选择了一个用例，它比我们在现实生活中遇到的用例更简单，但具有足够的复杂性来说明问题以及我们将如何解决它。</p>

<p>假设我们有一个需要显示实时更新的金融工具价格的应用程序。为了做到这一点，我们需要一个从符号到价格的查找表，每个我们有价格的工具都有一个条目。我们有一个可观察对象，它将在每次价格更新时发出一个对象，其中包含该表的最新值。这是我们想要测试的可观察对象。</p>

<p><strong>被测试的可观察对象依赖于两个源可观察对象:</strong></p>

<ul>
  <li>第一个将发出一个对象，其中包含一个符号和价格的单个工具，每次有一个价格更新的工具。(在现实世界的应用中，这个可观察对象将是 WebSocket 流上的抽象。)</li>
  <li>第二个表示一个事件，当触发时，应该将价格查找表的状态重置为其初始空状态。</li>
</ul>

<p>这个可观察对象的初始实现如下所示。然而，在没有测试的情况下，我们不能确定它的行为是否符合预期。</p>

<p>Stage 1: state.ts</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">Observable</span><span class="p">,</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">mergeWith</span><span class="p">,</span> <span class="nx">scan</span><span class="p">,</span> <span class="nx">startWith</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">rxjs</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">pricesDto$</span><span class="p">,</span> <span class="nx">resetPrices$</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./service</span><span class="dl">"</span><span class="p">;</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">prices$</span><span class="p">:</span> <span class="nx">Observable</span><span class="o">&lt;</span><span class="nx">Record</span><span class="o">&lt;</span><span class="nx">string</span><span class="p">,</span> <span class="nx">number</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nx">pricesDto$</span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span>
  <span class="nx">scan</span><span class="p">(</span>
    <span class="p">(</span><span class="nx">accum</span><span class="p">,</span> <span class="nx">current</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
      <span class="p">...</span><span class="nx">accum</span><span class="p">,</span>
      <span class="p">[</span><span class="nx">current</span><span class="p">.</span><span class="nx">symbol</span><span class="p">]:</span> <span class="nx">current</span><span class="p">.</span><span class="nx">price</span><span class="p">,</span>
    <span class="p">}),</span>
    <span class="p">{}</span>
  <span class="p">),</span>
  <span class="nx">mergeWith</span><span class="p">(</span><span class="nx">resetPrices$</span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">map</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">({})))),</span>
  <span class="nx">startWith</span><span class="p">({})</span>
<span class="p">);</span>
</code></pre></div></div>

<p>有关其他上下文，请参见 service。t 和 model。Ts</p>

<p>让我们设置测试文件。</p>

<p>Stage 1: state.test.ts</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">Subject</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">rxjs</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">Price</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./model</span><span class="dl">'</span>
<span class="c1">// create subjects to mock out the source observables that our</span>
<span class="c1">// observable under test depends on</span>
<span class="kd">const</span> <span class="nx">mockPricesDto$</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Subject</span><span class="o">&lt;</span><span class="nx">Price</span><span class="o">&gt;</span><span class="p">()</span>
<span class="kd">const</span> <span class="nx">mockResetPrices$</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Subject</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span><span class="p">()</span>
<span class="c1">// use doMock() rather than mock() so we can reference the</span>
<span class="c1">// variables containing the mock observables. mock() is hoisted</span>
<span class="c1">// so it does not allow referencing variables in the file scope.</span>
<span class="c1">// see https://vitest.dev/api/vi#vi-mock and</span>
<span class="c1">// https://vitest.dev/api/vi#vi-domock</span>
<span class="nx">vi</span><span class="p">.</span><span class="nx">doMock</span><span class="p">(</span><span class="dl">'</span><span class="s1">./service</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">({</span>
<span class="nx">pricesDto</span><span class="na">$</span><span class="p">:</span> <span class="nx">mockPricesDto$</span><span class="p">,</span>
<span class="nx">resetPrices</span><span class="na">$</span><span class="p">:</span> <span class="nx">mockResetPrices$</span><span class="p">,</span>
<span class="p">}))</span>
<span class="c1">// we need to dynamically import the observable under test</span>
<span class="c1">// after we call vi.doMock. see https://vitest.dev/api/vi#vi-domock</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">prices$</span> <span class="p">}</span> <span class="o">=</span> <span class="k">await</span> <span class="k">import</span><span class="p">(</span><span class="dl">'</span><span class="s1">./state</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">describe</span><span class="p">(</span><span class="dl">'</span><span class="s1">prices$</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="c1">// we are now ready to add our tests here</span>
<span class="p">})</span>
</code></pre></div></div>

<p>现在我们已经设置了测试文件的外壳，让我们添加一些基本断言。注意我们的 spyOnObservable()实用函数的用法。</p>

<p>Stage 2: state.test.ts</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">Subject</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">rxjs</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">Price</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./model</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">spyOnObservable</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./spyOnObservable</span><span class="dl">'</span>
<span class="c1">// create subjects to mock out the source observables that our</span>
<span class="c1">// observable under test depends on</span>
<span class="kd">const</span> <span class="nx">mockPricesDto$</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Subject</span><span class="o">&lt;</span><span class="nx">Price</span><span class="o">&gt;</span><span class="p">()</span>
<span class="kd">const</span> <span class="nx">mockResetPrices$</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Subject</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span><span class="p">()</span>
<span class="c1">// use doMock() rather than mock() so we can reference the</span>
<span class="c1">// variables containing the mock observables. mock() is hoisted</span>
<span class="c1">// so it does not allow referencing variables in the file scope.</span>
<span class="c1">// see https://vitest.dev/api/vi#vi-mock and</span>
<span class="c1">// https://vitest.dev/api/vi#vi-domock</span>
<span class="nx">vi</span><span class="p">.</span><span class="nx">doMock</span><span class="p">(</span><span class="dl">'</span><span class="s1">./service</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">({</span>
<span class="nx">pricesDto</span><span class="na">$</span><span class="p">:</span> <span class="nx">mockPricesDto$</span><span class="p">,</span>
<span class="nx">resetPrices</span><span class="na">$</span><span class="p">:</span> <span class="nx">mockResetPrices$</span><span class="p">,</span>
<span class="p">}))</span>
<span class="c1">// we need to dynamically import the observable under test</span>
<span class="c1">// after we call vi.doMock. see https://vitest.dev/api/vi#vi-domock</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">prices$</span> <span class="p">}</span> <span class="o">=</span> <span class="k">await</span> <span class="k">import</span><span class="p">(</span><span class="dl">'</span><span class="s1">./state</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">describe</span><span class="p">(</span><span class="dl">'</span><span class="s1">prices$</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// spy on the observable under test, using the spyOnObservable utility</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">latestEmission</span><span class="p">,</span> <span class="nx">error</span><span class="p">,</span> <span class="nx">subscription</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">spyOnObservable</span><span class="p">(</span><span class="nx">prices$</span><span class="p">)</span>
<span class="c1">// ensure we unsubscribe when we are done to avoid memory leaks</span>
<span class="nx">afterAll</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">subscription</span><span class="p">.</span><span class="nx">unsubscribe</span><span class="p">()</span>
<span class="p">})</span>
<span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">should initially emit empty object</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">latestEmission</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">({})</span>
<span class="p">})</span>
<span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">should not error</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">error</span><span class="p">).</span><span class="nx">not</span><span class="p">.</span><span class="nx">toBeCalled</span><span class="p">()</span>
<span class="p">})</span>
<span class="p">})</span>
</code></pre></div></div>

<p>我们的测试通过了。</p>

<p><img src="/assets/image.png" alt="alt text" /></p>

<p>RxJS 可观察对象:第二阶段——测试通过</p>

<p>到目前为止一切顺利。现在，让我们添加一些断言，说明源可观察对象 pricesDto$发出时的行为。</p>

<p>Stage 3: state.test.ts</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">Subject</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">rxjs</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">Price</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./model</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">spyOnObservable</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./spyOnObservable</span><span class="dl">'</span>
<span class="c1">// create subjects to mock out the source observables that our</span>
<span class="c1">// observable under test depends on</span>
<span class="kd">const</span> <span class="nx">mockPricesDto$</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Subject</span><span class="o">&lt;</span><span class="nx">Price</span><span class="o">&gt;</span><span class="p">()</span>
<span class="kd">const</span> <span class="nx">mockResetPrices$</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Subject</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span><span class="p">()</span>
<span class="c1">// use doMock() rather than mock() so we can reference the</span>
<span class="c1">// variables containing the mock observables. mock() is hoisted</span>
<span class="c1">// so it does not allow referencing variables in the file scope.</span>
<span class="c1">// see https://vitest.dev/api/vi#vi-mock and</span>
<span class="c1">// https://vitest.dev/api/vi#vi-domock</span>
<span class="nx">vi</span><span class="p">.</span><span class="nx">doMock</span><span class="p">(</span><span class="dl">'</span><span class="s1">./service</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">({</span>
<span class="nx">pricesDto</span><span class="na">$</span><span class="p">:</span> <span class="nx">mockPricesDto$</span><span class="p">,</span>
<span class="nx">resetPrices</span><span class="na">$</span><span class="p">:</span> <span class="nx">mockResetPrices$</span><span class="p">,</span>
<span class="p">}))</span>
<span class="c1">// we need to dynamically import the observable under test</span>
<span class="c1">// after we call vi.doMock. see https://vitest.dev/api/vi#vi-domock</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">prices$</span> <span class="p">}</span> <span class="o">=</span> <span class="k">await</span> <span class="k">import</span><span class="p">(</span><span class="dl">'</span><span class="s1">./state</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">describe</span><span class="p">(</span><span class="dl">'</span><span class="s1">prices$</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// spy on the observable under test, using the spyOnObservable utility</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">latestEmission</span><span class="p">,</span> <span class="nx">error</span><span class="p">,</span> <span class="nx">subscription</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">spyOnObservable</span><span class="p">(</span><span class="nx">prices$</span><span class="p">)</span>
<span class="c1">// ensure we unsubscribe when we are done to avoid memory leaks</span>
<span class="nx">afterAll</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">subscription</span><span class="p">.</span><span class="nx">unsubscribe</span><span class="p">()</span>
<span class="p">})</span>
<span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">should initially emit empty object</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">latestEmission</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">({})</span>
<span class="p">})</span>
<span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">should emit object containing latest prices after pricesDto$ emits</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="c1">// call next() on the subject that mocks out the source observable</span>
<span class="c1">// priceDto$ that the observable under test depends on to simulate</span>
<span class="c1">// that observable emitting prices, and ensure the new price is</span>
<span class="c1">// emitted as expected in the observable under test</span>
<span class="nx">mockPricesDto$</span><span class="p">.</span><span class="nx">next</span><span class="p">({</span> <span class="na">symbol</span><span class="p">:</span> <span class="dl">'</span><span class="s1">XOM</span><span class="dl">'</span><span class="p">,</span> <span class="na">price</span><span class="p">:</span> <span class="mf">48.17</span> <span class="p">})</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">latestEmission</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">({</span> <span class="na">XOM</span><span class="p">:</span> <span class="mf">48.17</span> <span class="p">})</span>
    <span class="c1">// add another instrument/price, ensure both instruments</span>
    <span class="c1">// appear in the resulting emission</span>
    <span class="nx">mockPricesDto$</span><span class="p">.</span><span class="nx">next</span><span class="p">({</span> <span class="na">symbol</span><span class="p">:</span> <span class="dl">'</span><span class="s1">BA</span><span class="dl">'</span><span class="p">,</span> <span class="na">price</span><span class="p">:</span> <span class="mf">218.93</span> <span class="p">})</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">latestEmission</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">({</span> <span class="na">XOM</span><span class="p">:</span> <span class="mf">48.17</span><span class="p">,</span> <span class="na">BA</span><span class="p">:</span> <span class="mf">218.93</span> <span class="p">})</span>
<span class="c1">// update the price of the first instrument, ensure the price is</span>
<span class="c1">// updated in the resulting emission</span>
<span class="nx">mockPricesDto$</span><span class="p">.</span><span class="nx">next</span><span class="p">({</span> <span class="na">symbol</span><span class="p">:</span> <span class="dl">'</span><span class="s1">XOM</span><span class="dl">'</span><span class="p">,</span> <span class="na">price</span><span class="p">:</span> <span class="mf">48.21</span> <span class="p">})</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">latestEmission</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">({</span> <span class="na">XOM</span><span class="p">:</span> <span class="mf">48.21</span><span class="p">,</span> <span class="na">BA</span><span class="p">:</span> <span class="mf">218.93</span> <span class="p">})</span>
<span class="p">})</span>
<span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">should not error</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">error</span><span class="p">).</span><span class="nx">not</span><span class="p">.</span><span class="nx">toBeCalled</span><span class="p">()</span>
<span class="p">})</span>
<span class="p">})</span>
</code></pre></div></div>

<p>太好了，我们的测试仍然通过了</p>

<p><img src="/assets/image-1.png" alt="alt text" /></p>

<p>RxJS可观察对象:阶段3——测试通过</p>

<p>现在让我们为重置事件添加一个断言。</p>

<p>Stage 4: state.test.ts</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">Subject</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">rxjs</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">Price</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./model</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">spyOnObservable</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./spyOnObservable</span><span class="dl">'</span>
<span class="c1">// create subjects to mock out the source observables that our</span>
<span class="c1">// observable under test depends on</span>
<span class="kd">const</span> <span class="nx">mockPricesDto$</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Subject</span><span class="o">&lt;</span><span class="nx">Price</span><span class="o">&gt;</span><span class="p">()</span>
<span class="kd">const</span> <span class="nx">mockResetPrices$</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Subject</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span><span class="p">()</span>
<span class="c1">// use doMock() rather than mock() so we can reference the</span>
<span class="c1">// variables containing the mock observables. mock() is hoisted</span>
<span class="c1">// so it does not allow referencing variables in the file scope.</span>
<span class="c1">// see https://vitest.dev/api/vi#vi-mock and</span>
<span class="c1">// https://vitest.dev/api/vi#vi-domock</span>
<span class="nx">vi</span><span class="p">.</span><span class="nx">doMock</span><span class="p">(</span><span class="dl">'</span><span class="s1">./service</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">({</span>
<span class="nx">pricesDto</span><span class="na">$</span><span class="p">:</span> <span class="nx">mockPricesDto$</span><span class="p">,</span>
<span class="nx">resetPrices</span><span class="na">$</span><span class="p">:</span> <span class="nx">mockResetPrices$</span><span class="p">,</span>
<span class="p">}))</span>
<span class="c1">// we need to dynamically import the observable under test</span>
<span class="c1">// after we call vi.doMock. see https://vitest.dev/api/vi#vi-domock</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">prices$</span> <span class="p">}</span> <span class="o">=</span> <span class="k">await</span> <span class="k">import</span><span class="p">(</span><span class="dl">'</span><span class="s1">./state</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">describe</span><span class="p">(</span><span class="dl">'</span><span class="s1">prices$</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// spy on the observable under test, using the spyOnObservable utility</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">latestEmission</span><span class="p">,</span> <span class="nx">error</span><span class="p">,</span> <span class="nx">subscription</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">spyOnObservable</span><span class="p">(</span><span class="nx">prices$</span><span class="p">)</span>
<span class="c1">// ensure we unsubscribe when we are done to avoid memory leaks</span>
<span class="nx">afterAll</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">subscription</span><span class="p">.</span><span class="nx">unsubscribe</span><span class="p">()</span>
<span class="p">})</span>
<span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">should initially emit empty object</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">latestEmission</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">({})</span>
<span class="p">})</span>
<span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">should emit object containing latest prices after pricesDto$ emits</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="c1">// call next() on the subject that mocks out the source observable</span>
<span class="c1">// priceDto$ that the observable under test depends on, to simulate</span>
<span class="c1">// that observable emitting prices, and ensure the new price is</span>
<span class="c1">// emitted as expected in the observable under test</span>
<span class="nx">mockPricesDto$</span><span class="p">.</span><span class="nx">next</span><span class="p">({</span> <span class="na">symbol</span><span class="p">:</span> <span class="dl">'</span><span class="s1">XOM</span><span class="dl">'</span><span class="p">,</span> <span class="na">price</span><span class="p">:</span> <span class="mf">48.17</span> <span class="p">})</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">latestEmission</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">({</span> <span class="na">XOM</span><span class="p">:</span> <span class="mf">48.17</span> <span class="p">})</span>
    <span class="c1">// add another instrument/price, ensure both instruments</span>
    <span class="c1">// appear in the resulting emission</span>
    <span class="nx">mockPricesDto$</span><span class="p">.</span><span class="nx">next</span><span class="p">({</span> <span class="na">symbol</span><span class="p">:</span> <span class="dl">'</span><span class="s1">BA</span><span class="dl">'</span><span class="p">,</span> <span class="na">price</span><span class="p">:</span> <span class="mf">218.93</span> <span class="p">})</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">latestEmission</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">({</span> <span class="na">XOM</span><span class="p">:</span> <span class="mf">48.17</span><span class="p">,</span> <span class="na">BA</span><span class="p">:</span> <span class="mf">218.93</span> <span class="p">})</span>
<span class="c1">// update the price of the first instrument, ensure the price is</span>
<span class="c1">// updated in the resulting emission</span>
<span class="nx">mockPricesDto$</span><span class="p">.</span><span class="nx">next</span><span class="p">({</span> <span class="na">symbol</span><span class="p">:</span> <span class="dl">'</span><span class="s1">XOM</span><span class="dl">'</span><span class="p">,</span> <span class="na">price</span><span class="p">:</span> <span class="mf">48.21</span> <span class="p">})</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">latestEmission</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">({</span> <span class="na">XOM</span><span class="p">:</span> <span class="mf">48.21</span><span class="p">,</span> <span class="na">BA</span><span class="p">:</span> <span class="mf">218.93</span> <span class="p">})</span>
  <span class="p">})</span>
  <span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">should emit empty object after resetPrices$ emits</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="c1">// call next() on the subject that mocks out the source observable</span>
<span class="c1">// resetPrices$ that the observable under test depends on, to simulate</span>
<span class="c1">// that observable emitting, and ensure that the prices lookup table</span>
<span class="c1">// is reset to an empty object</span>
<span class="nx">mockResetPrices$</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">latestEmission</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">({})</span>
<span class="p">})</span>
<span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">should not error</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">error</span><span class="p">).</span><span class="nx">not</span><span class="p">.</span><span class="nx">toBeCalled</span><span class="p">()</span>
<span class="p">})</span>
<span class="p">})</span>
</code></pre></div></div>

<p>太好了，测试又通过了。</p>

<p><img src="/assets/image-2.png" alt="alt text" /></p>

<p>RxJS可观察对象:阶段4 -测试通过</p>

<p>现在，让我们添加一个断言，即在重置后流入的下一个价格中，查找表中只有新价格。
Stage 5: state.test.ts</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">Subject</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">rxjs</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">Price</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./model</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">spyOnObservable</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./spyOnObservable</span><span class="dl">'</span>
<span class="c1">// create subjects to mock out the source observables that our</span>
<span class="c1">// observable under test depends on</span>
<span class="kd">const</span> <span class="nx">mockPricesDto$</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Subject</span><span class="o">&lt;</span><span class="nx">Price</span><span class="o">&gt;</span><span class="p">()</span>
<span class="kd">const</span> <span class="nx">mockResetPrices$</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Subject</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span><span class="p">()</span>
<span class="c1">// use doMock() rather than mock() so we can reference the</span>
<span class="c1">// variables containing the mock observables. mock() is hoisted</span>
<span class="c1">// so it does not allow referencing variables in the file scope.</span>
<span class="c1">// see https://vitest.dev/api/vi#vi-mock and</span>
<span class="c1">// https://vitest.dev/api/vi#vi-domock</span>
<span class="nx">vi</span><span class="p">.</span><span class="nx">doMock</span><span class="p">(</span><span class="dl">'</span><span class="s1">./service</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">({</span>
<span class="nx">pricesDto</span><span class="na">$</span><span class="p">:</span> <span class="nx">mockPricesDto$</span><span class="p">,</span>
<span class="nx">resetPrices</span><span class="na">$</span><span class="p">:</span> <span class="nx">mockResetPrices$</span><span class="p">,</span>
<span class="p">}))</span>
<span class="c1">// we need to dynamically import the observable under test</span>
<span class="c1">// after we call vi.doMock. see https://vitest.dev/api/vi#vi-domock</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">prices$</span> <span class="p">}</span> <span class="o">=</span> <span class="k">await</span> <span class="k">import</span><span class="p">(</span><span class="dl">'</span><span class="s1">./state</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">describe</span><span class="p">(</span><span class="dl">'</span><span class="s1">prices$</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// spy on the observable under test, using the spyOnObservable utility</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">latestEmission</span><span class="p">,</span> <span class="nx">error</span><span class="p">,</span> <span class="nx">subscription</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">spyOnObservable</span><span class="p">(</span><span class="nx">prices$</span><span class="p">)</span>
<span class="c1">// ensure we unsubscribe when we are done to avoid memory leaks</span>
<span class="nx">afterAll</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">subscription</span><span class="p">.</span><span class="nx">unsubscribe</span><span class="p">()</span>
<span class="p">})</span>
<span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">should initially emit empty object</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">latestEmission</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">({})</span>
<span class="p">})</span>
<span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">should emit object containing latest prices after pricesDto$ emits</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="c1">// call next() on the subject that mocks out the source observable</span>
<span class="c1">// priceDto$ that the observable under test depends on, to simulate</span>
<span class="c1">// that observable emitting prices, and ensure the new price is</span>
<span class="c1">// emitted as expected in the observable under test</span>
<span class="nx">mockPricesDto$</span><span class="p">.</span><span class="nx">next</span><span class="p">({</span> <span class="na">symbol</span><span class="p">:</span> <span class="dl">'</span><span class="s1">XOM</span><span class="dl">'</span><span class="p">,</span> <span class="na">price</span><span class="p">:</span> <span class="mf">48.17</span> <span class="p">})</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">latestEmission</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">({</span> <span class="na">XOM</span><span class="p">:</span> <span class="mf">48.17</span> <span class="p">})</span>
    <span class="c1">// add another instrument/price, ensure both instruments</span>
    <span class="c1">// appear in the resulting emission</span>
    <span class="nx">mockPricesDto$</span><span class="p">.</span><span class="nx">next</span><span class="p">({</span> <span class="na">symbol</span><span class="p">:</span> <span class="dl">'</span><span class="s1">BA</span><span class="dl">'</span><span class="p">,</span> <span class="na">price</span><span class="p">:</span> <span class="mf">218.93</span> <span class="p">})</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">latestEmission</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">({</span> <span class="na">XOM</span><span class="p">:</span> <span class="mf">48.17</span><span class="p">,</span> <span class="na">BA</span><span class="p">:</span> <span class="mf">218.93</span> <span class="p">})</span>
<span class="c1">// update the price of the first instrument, ensure the price is</span>
<span class="c1">// updated in the resulting emission</span>
<span class="nx">mockPricesDto$</span><span class="p">.</span><span class="nx">next</span><span class="p">({</span> <span class="na">symbol</span><span class="p">:</span> <span class="dl">'</span><span class="s1">XOM</span><span class="dl">'</span><span class="p">,</span> <span class="na">price</span><span class="p">:</span> <span class="mf">48.21</span> <span class="p">})</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">latestEmission</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">({</span> <span class="na">XOM</span><span class="p">:</span> <span class="mf">48.21</span><span class="p">,</span> <span class="na">BA</span><span class="p">:</span> <span class="mf">218.93</span> <span class="p">})</span>
  <span class="p">})</span>
  <span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">should emit empty object after resetPrices$ emits</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="c1">// call next() on the subject that mocks out the source observable</span>
<span class="c1">// resetPrices$ that the observable under test depends on, to simulate</span>
<span class="c1">// that observable emitting, and ensure that the prices lookup table</span>
<span class="c1">// is reset to an empty object</span>
<span class="nx">mockResetPrices$</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">latestEmission</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">({})</span>
  <span class="p">})</span>
  <span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">should emit object containing only the latest prices after pricesDto$ emits</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">mockPricesDto$</span><span class="p">.</span><span class="nx">next</span><span class="p">({</span> <span class="na">symbol</span><span class="p">:</span> <span class="dl">'</span><span class="s1">HD</span><span class="dl">'</span><span class="p">,</span> <span class="na">price</span><span class="p">:</span> <span class="mf">332.12</span> <span class="p">})</span>
    <span class="nx">mockPricesDto$</span><span class="p">.</span><span class="nx">next</span><span class="p">({</span> <span class="na">symbol</span><span class="p">:</span> <span class="dl">'</span><span class="s1">AA</span><span class="dl">'</span><span class="p">,</span> <span class="na">price</span><span class="p">:</span> <span class="mf">24.49</span> <span class="p">})</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">latestEmission</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">({</span> <span class="na">HD</span><span class="p">:</span> <span class="mf">332.12</span><span class="p">,</span> <span class="na">AA</span><span class="p">:</span> <span class="mf">24.49</span> <span class="p">})</span>
<span class="p">})</span>
<span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">should not error</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">error</span><span class="p">).</span><span class="nx">not</span><span class="p">.</span><span class="nx">toBeCalled</span><span class="p">()</span>
<span class="p">})</span>
<span class="p">})</span>
</code></pre></div></div>

<p>…我们的测试不通过</p>

<p><img src="/assets/image-3.png" alt="alt text" /></p>

<p>RxJS可观察对象:第5阶段——测试失败</p>

<p>看来我们的测试发现了实现中的一个bug !我们希望在reset可观察对象发出时将状态重置为空对象。但是我们传递给scan()的reducer函数中的accumulator对象即使在重置之后也会保留状态。让我们通过在scan()之前移动mergeWith()来解决这个问题，并在reducer函数中添加一个条件，以便在重置事件中用空对象替换状态。(在这种情况下，流入scan()的值将是false而不是Price对象。)</p>

<p>Stage 6: state.ts</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">Observable</span><span class="p">,</span> <span class="nx">mergeWith</span><span class="p">,</span> <span class="nx">scan</span><span class="p">,</span> <span class="nx">startWith</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">rxjs</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">pricesDto$</span><span class="p">,</span> <span class="nx">resetPrices$</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./service</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">Price</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./model</span><span class="dl">'</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">prices$</span><span class="p">:</span> <span class="nx">Observable</span><span class="o">&lt;</span><span class="nx">Record</span><span class="o">&lt;</span><span class="nx">string</span><span class="p">,</span> <span class="nx">number</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nx">pricesDto$</span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span>
<span class="nx">mergeWith</span><span class="p">(</span><span class="nx">resetPrices$</span><span class="p">),</span>
<span class="nx">scan</span><span class="p">(</span>
<span class="p">(</span><span class="nx">accum</span><span class="p">,</span> <span class="nx">current</span><span class="p">:</span> <span class="nx">Price</span> <span class="o">|</span> <span class="k">void</span><span class="p">)</span> <span class="o">=&gt;</span>
<span class="o">!</span><span class="nx">current</span>
<span class="p">?</span> <span class="p">{}</span>
<span class="p">:</span> <span class="p">{</span>
<span class="p">...</span><span class="nx">accum</span><span class="p">,</span>
<span class="p">[</span><span class="nx">current</span><span class="p">.</span><span class="nx">symbol</span><span class="p">]:</span> <span class="nx">current</span><span class="p">.</span><span class="nx">price</span><span class="p">,</span>
<span class="p">},</span>
<span class="p">{}</span>
<span class="p">),</span>
<span class="nx">startWith</span><span class="p">({})</span>
<span class="p">)</span>
</code></pre></div></div>

<p>我们的测试现在又通过了，这给了我们信心，我们的观察链做了我们想要它做的事情。</p>

<p><img src="/assets/image-4.png" alt="alt text" /></p>

<h2 id="rxjs观察链单元测试解决方案概述">RxJS观察链单元测试:解决方案概述</h2>

<p>spyOnObservable实用程序提供了一个易于使用的API来监视可观察对象，以方便断言它们的行为。这个实用程序与RxJS Subjects模拟上游可观察对象配对，定义了一个可扩展的模式，用于编写语法愉悦的单元测试，模拟观察链在现实世界中的行为，通过上游源可观察对象提供各种输入。</p>

<p>你可以随意复制spyOnObservable，根据你认为合适的需要进行调整，并使用它而不注明出处。</p>

<h2 id="进一步的资源">进一步的资源</h2>

<p>如果您有兴趣了解更多关于如何实现响应式编程原则的信息，请参阅reactive Trader®及其开源代码库。Reactive Trader®是Adaptive的实时外汇(FX)和信用交易平台，旨在展示整个应用程序堆栈的反应性编程原则。</p>

<p>如果你想了解React-RxJS，一个提供绑定来将RxJS可观察对象与React集成的库，请参阅我们2020年的文章Why React RxJS。</p>

<h2 id="附录a考虑单元测试rxjs观察链的替代解决方案">附录A:考虑单元测试RxJS观察链的替代解决方案</h2>

<p>Marble测试非常适合测试RxJS操作符(如map()、first()等)。例如，创建操作符函数的工厂函数。事实上，RxJS代码库中RxJS操作符的单元测试使用大理石测试。当测试一个接受一个可观察对象并返回另一个可观察对象的函数时，大理石测试也很有用。</p>

<p>然而，对于我们测试有状态观察链的用例，大理石测试似乎并不适合。此外，大理石测试对整个产生的排放流起作用。我们希望能够以交互的方式测试游戏中排放的内容，这样我们就可以在每次排放后通过可观测源验证预期结果。</p>

<p>我们简要探讨的另一种方法是订阅可观察对象，并在观察者中进行测试断言(例如，将下一个处理程序传递给subscribe())。这对于发出多个值的可观察对象来说效果很差，它只在你知道可观察对象将完成时才有效，并且需要样板文件来处理在可观察对象完成时实现异步测试的承诺。在某种程度上，您可以通过使用take()等操作符强制完成(但是您需要确切地知道要关注多少次释放)，以及toArray()来检查释放的多个值，从而解决这个问题。我们发现这种方法并不令人满意。</p>

<p>Author: Bruce Harris</p>

<p><a href="https://weareadaptive.com/2024/01/09/unit-testing-rxjs-observables-a-practical-guide/">原文链接：https://weareadaptive.com/2024/01/09/unit-testing-rxjs-observables-a-practical-guide/</a></p>

      </div>

        <!-- Configure Disqus --></div>
  </main></body>
</html>